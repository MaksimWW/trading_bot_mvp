–û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π —Ñ–∞–π–ª src/morning_brief.py. –ù–∞–π–¥–∏ —ç—Ç–∏ —Å—Ç—Ä–æ–∫–∏ –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞:

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import json

–ò –¥–æ–±–∞–≤—å –ø–æ—Å–ª–µ –Ω–∏—Ö:

from src.rss_parser import RSSParser

–ó–∞—Ç–µ–º –Ω–∞–π–¥–∏ –º–µ—Ç–æ–¥ __init__ –≤ –∫–ª–∞—Å—Å–µ MorningBriefGenerator:

    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã"""
        # –ò–º–ø–æ—Ä—Ç—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è RSS parser
        self.top_tickers = ["SBER", "GAZP", "YNDX", "LKOH", "ROSN"]
        self.overnight_hours = 12  # –ê–Ω–∞–ª–∏–∑ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 12 —á–∞—Å–æ–≤

–ò –∑–∞–º–µ–Ω–∏ –Ω–∞:

    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã"""
        self.rss_parser = RSSParser()
        self.top_tickers = ["SBER", "GAZP", "YNDX", "LKOH", "ROSN"]
        self.overnight_hours = 12  # –ê–Ω–∞–ª–∏–∑ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 12 —á–∞—Å–æ–≤

–¢–µ–ø–µ—Ä—å –Ω–∞–π–¥–∏ –º–µ—Ç–æ–¥ generate_morning_brief –∏ –∑–∞–º–µ–Ω–∏ –µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ:

    async def generate_morning_brief(self, user_id: Optional[str] = None) -> MorningBriefData:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–ª–Ω–æ–≥–æ —É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –±—Ä–∏—Ñ–∏–Ω–≥–∞
        
        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            
        Returns:
            MorningBriefData: –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –±—Ä–∏—Ñ–∏–Ω–≥–∞
        """
        logger.info("–ù–∞—á–∏–Ω–∞—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –±—Ä–∏—Ñ–∏–Ω–≥–∞...")
        
        try:
            # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤–æ—Å—Ç–∏ –∑–∞ –Ω–æ—á—å —á–µ—Ä–µ–∑ RSS
            async with self.rss_parser as parser:
                # –ü–æ–ª—É—á–∞–µ–º –æ–±—â–∏–µ —Ä—ã–Ω–æ—á–Ω—ã–µ –Ω–æ–≤–æ—Å—Ç–∏
                market_news = await parser.get_market_news(self.overnight_hours)
                
                # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤–æ—Å—Ç–∏ –ø–æ —Ç–æ–ø —Ç–∏–∫–µ—Ä–∞–º
                ticker_news = []
                for ticker in self.top_tickers:
                    news = await parser.get_ticker_news(ticker, self.overnight_hours)
                    ticker_news.extend(news[:2])  # –¢–æ–ø-2 –Ω–æ–≤–æ—Å—Ç–∏ –ø–æ –∫–∞–∂–¥–æ–º—É —Ç–∏–∫–µ—Ä—É
                
                # –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ –Ω–æ–≤–æ—Å—Ç–∏
                all_news = market_news + ticker_news
                
                # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–µ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —Ä—ã–Ω–∫–∞
                market_sentiment = self._calculate_market_sentiment(all_news)
                
                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Å–∏–≥–Ω–∞–ª—ã (–∑–∞–≥–ª—É—à–∫–∞)
                technical_signals = self._generate_mock_technical_signals()
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
                recommendations = self._generate_recommendations(all_news, technical_signals)
                
                # –°–æ–∑–¥–∞–µ–º –æ–±–∑–æ—Ä —Ä—ã–Ω–∫–∞
                market_overview = self._generate_market_overview(all_news, market_sentiment)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∏—Å–∫–∏
                risk_alerts = self._check_risk_alerts(all_news, market_sentiment)
                
                brief_data = MorningBriefData(
                    date=datetime.now().strftime("%Y-%m-%d"),
                    market_sentiment=market_sentiment,
                    top_news=all_news[:10],  # –¢–æ–ø-10 –Ω–æ–≤–æ—Å—Ç–µ–π
                    technical_signals=technical_signals,
                    trading_recommendations=recommendations,
                    market_overview=market_overview,
                    risk_alerts=risk_alerts,
                    portfolio_status=None
                )
                
                logger.info("–£—Ç—Ä–µ–Ω–Ω–∏–π –±—Ä–∏—Ñ–∏–Ω–≥ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω")
                return brief_data
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –±—Ä–∏—Ñ–∏–Ω–≥–∞: {e}")
            raise

–ò –¥–æ–±–∞–≤—å —ç—Ç–∏ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –ø–µ—Ä–µ–¥ format_morning_brief_for_telegram:

    def _calculate_market_sentiment(self, news_list: List[Dict]) -> float:
        """–†–∞—Å—á–µ—Ç –æ–±—â–µ–≥–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è —Ä—ã–Ω–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–æ–≤–æ—Å—Ç–µ–π"""
        if not news_list:
            return 0.0
        
        # –ü—Ä–æ—Å—Ç–æ–π —Ä–∞—Å—á–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
        positive_words = ['—Ä–æ—Å—Ç', '—É–≤–µ–ª–∏—á–µ–Ω–∏–µ', '–ø—Ä–∏–±—ã–ª—å', '–¥–æ—Ö–æ–¥—ã', '—É—Å–ø–µ—Ö', '—Ä–∞–∑–≤–∏—Ç–∏–µ']
        negative_words = ['–ø–∞–¥–µ–Ω–∏–µ', '—Å–Ω–∏–∂–µ–Ω–∏–µ', '—É–±—ã—Ç–∫–∏', '–∫—Ä–∏–∑–∏—Å', '–ø—Ä–æ–±–ª–µ–º—ã', '—Å–∞–Ω–∫—Ü–∏–∏']
        
        sentiment_score = 0.0
        for news in news_list:
            text = f"{news.get('title', '')} {news.get('description', '')}".lower()
            
            for word in positive_words:
                if word in text:
                    sentiment_score += 0.1
            
            for word in negative_words:
                if word in text:
                    sentiment_score -= 0.1
        
        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [-1, 1]
        max_sentiment = len(news_list) * 0.3
        normalized = sentiment_score / max_sentiment if max_sentiment > 0 else 0
        return max(-1.0, min(1.0, normalized))

    def _generate_mock_technical_signals(self) -> Dict[str, Dict[str, Any]]:
        """–í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤"""
        signals = {}
        for ticker in self.top_tickers:
            signals[ticker] = {
                'rsi': 50.0,
                'rsi_signal': 'NEUTRAL',
                'macd': 'NEUTRAL',
                'bollinger': 'NEUTRAL',
                'overall_signal': 'NEUTRAL',
                'confidence': 0.5
            }
        return signals

    def _generate_recommendations(self, news_list: List[Dict], technical_signals: Dict) -> List[Dict[str, Any]]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""
        recommendations = []
        
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–æ–≤–æ—Å—Ç–∏ –ø–æ —Ç–∏–∫–µ—Ä–∞–º
        ticker_sentiment = {}
        for news in news_list:
            ticker = news.get('ticker')
            if ticker:
                relevance = news.get('relevance_score', 0)
                if ticker not in ticker_sentiment:
                    ticker_sentiment[ticker] = []
                ticker_sentiment[ticker].append(relevance)
        
        # –°–æ–∑–¥–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è —Ç–∏–∫–µ—Ä–æ–≤ —Å –Ω–æ–≤–æ—Å—Ç—è–º–∏
        for ticker, scores in ticker_sentiment.items():
            avg_score = sum(scores) / len(scores) if scores else 0
            
            if avg_score > 0.3:
                action = "BUY"
                priority = avg_score
            elif avg_score < -0.3:
                action = "SELL"
                priority = abs(avg_score)
            else:
                action = "HOLD"
                priority = 0.1
            
            recommendations.append({
                'ticker': ticker,
                'action': action,
                'priority': priority,
                'reasoning': f"–ù–æ–≤–æ—Å—Ç–Ω–æ–π –∞–Ω–∞–ª–∏–∑ (—Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å: {avg_score:.2f})"
            })
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É
        recommendations.sort(key=lambda x: x['priority'], reverse=True)
        return recommendations[:5]

    def _generate_market_overview(self, news_list: List[Dict], sentiment: float) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–±–∑–æ—Ä–∞ —Ä—ã–Ω–∫–∞"""
        news_count = len(news_list)
        
        if sentiment > 0.2:
            sentiment_text = "–ø–æ–∑–∏—Ç–∏–≤–Ω—ã–º –Ω–∞—Å—Ç—Ä–æ–µ–º"
        elif sentiment < -0.2:
            sentiment_text = "–Ω–µ–≥–∞—Ç–∏–≤–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è–º–∏"
        else:
            sentiment_text = "–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–º —Ñ–æ–Ω–æ–º"
        
        overview = f"–£—Ç—Ä–µ–Ω–Ω–∏–π –æ–±–∑–æ—Ä –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç {sentiment_text} –Ω–∞ —Ä—ã–Ω–∫–µ. "
        overview += f"–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {news_count} –Ω–æ–≤–æ—Å—Ç–µ–π –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ {self.overnight_hours} —á–∞—Å–æ–≤. "
        
        if news_list:
            top_sources = set([news.get('source', 'N/A') for news in news_list[:5]])
            overview += f"–û—Å–Ω–æ–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏: {', '.join(list(top_sources)[:3])}."
        
        return overview

    def _check_risk_alerts(self, news_list: List[Dict], sentiment: float) -> List[str]:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∏—Å–∫–æ–≤—ã—Ö —Å–∏—Ç—É–∞—Ü–∏–π"""
        alerts = []
        
        if sentiment < -0.5:
            alerts.append("üö® –ö—Ä–∞–π–Ω–µ –Ω–µ–≥–∞—Ç–∏–≤–Ω–æ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —Ä—ã–Ω–∫–∞")
        
        if len(news_list) < 3:
            alerts.append("‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–ª–æ–≤ –≤ –Ω–æ–≤–æ—Å—Ç—è—Ö
        critical_words = ['—Å–∞–Ω–∫—Ü–∏–∏', '–∫—Ä–∏–∑–∏—Å', '–æ–±–≤–∞–ª', '–¥–µ—Ñ–æ–ª—Ç']
        for news in news_list[:5]:
            text = f"{news.get('title', '')} {news.get('description', '')}".lower()
            for word in critical_words:
                if word in text:
                    alerts.append(f"‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã —É–ø–æ–º–∏–Ω–∞–Ω–∏—è: {word}")
                    break
        
        return alerts